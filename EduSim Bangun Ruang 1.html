<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulasi Bangun Ruang 3D</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script>
    window.MathJax = {
        tex: {
            inlineMath: [['\\(', '\\)']],
            displayMath: [['\\[', '\\]']]
        },
        svg: {
            fontCache: 'global'
        },
        startup: {
            ready: function() {
                MathJax.startup.defaultReady();
            }
        }
    };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
    <style>
        :root {
            --primary-color: #5D5CDE;
            --secondary-color: #FF6B6B;
            --accent-color: #FFD166;
            --gradient-start: #4158D0;
            --gradient-middle: #C850C0;
            --gradient-end: #FFCC70;
            --text-light: #F7FFF7;
            --text-dark: #2A2A2A;
            --bg-light: #FFFFFF;
            --bg-dark: #181818;
            --card-light: #FFFFFF;
            --card-dark: #252546;
            --formula-light: #f1f5f9;
            --formula-dark: #2d2d5d;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 15px;
            transition: background-color 0.3s ease;
        }
        
        @media (prefers-color-scheme: dark) {
            body {
                background-color: var(--bg-dark);
                color: var(--text-light);
            }
            .card {
                background-color: var(--card-dark);
                color: var(--text-light);
            }
            .formula-box {
                background-color: var(--formula-dark);
            }
            .slider {
                background: #4a4a6a;
            }
            .slider::-webkit-slider-thumb {
                background: var(--accent-color);
            }
            .toggle-label {
                color: var(--text-light);
            }
        }
        
        @media (prefers-color-scheme: light) {
            body {
                background-color: var(--bg-light);
                color: var(--text-dark);
            }
            .card {
                background-color: var(--card-light);
                color: var(--text-dark);
            }
            .formula-box {
                background-color: var(--formula-light);
            }
            .slider {
                background: #d3d3d3;
            }
            .slider::-webkit-slider-thumb {
                background: var(--primary-color);
            }
            .toggle-label {
                color: var(--text-dark);
            }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .card {
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2);
        }
        
        .grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }
        
        @media (min-width: 768px) {
            .grid {
                grid-template-columns: 1fr 1fr;
            }
        }
        
        .shape-btn {
            background-color: var(--primary-color);
            color: white;
            border-radius: 10px;
            padding: 10px 16px;
            margin: 5px;
            transition: all 0.2s ease;
            border: none;
            cursor: pointer;
            font-weight: 600;
        }
        
        .shape-btn:hover {
            transform: scale(1.05);
            background-color: var(--secondary-color);
        }
        
        .shape-btn.active {
            background: linear-gradient(90deg, var(--gradient-start), var(--gradient-middle));
            color: white;
            font-weight: bold;
        }
        
        .formula-box {
            border-radius: 10px;
            padding: 15px;
            margin-top: 10px;
            border-left: 5px solid var(--secondary-color);
        }
        
        .canvas-container {
            position: relative;
            height: 350px;
            border-radius: 15px;
            overflow: hidden;
            background: linear-gradient(135deg, var(--gradient-start), var(--gradient-middle), var(--gradient-end));
        }
        
        #scene {
            width: 100%;
            height: 100%;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }
        
        .slider-container {
            width: 100%;
            max-width: 200px;
        }
        
        .slider {
            width: 100%;
            height: 10px;
            border-radius: 5px;
            outline: none;
            -webkit-appearance: none;
            margin-top: 8px;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .rotate-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 0.85rem;
        }
        
        .axis-label {
            color: white;
            font-size: 0.85rem;
            padding: 2px 6px;
            border-radius: 3px;
            position: absolute;
            font-weight: bold;
        }
        
        .axis-x {
            color: #ff5555;
            background-color: rgba(255, 85, 85, 0.2);
        }
        
        .axis-y {
            color: #55ff55;
            background-color: rgba(85, 255, 85, 0.2);
        }
        
        .axis-z {
            color: #5555ff;
            background-color: rgba(85, 85, 255, 0.2);
        }
        
        .toggle-container {
            display: flex;
            align-items: center;
            margin-top: 10px;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
            margin-right: 5px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: var(--primary-color);
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }
        
        .surface-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 0.85rem;
            max-width: 200px;
            display: none;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .title {
            animation: pulse 3s infinite;
            background: linear-gradient(90deg, var(--gradient-start), var(--gradient-middle), var(--gradient-end));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            display: inline-block;
            font-size: 2.5rem;
            font-weight: 800;
            text-align: center;
            margin-bottom: 1.5rem;
            width: 100%;
        }
        
        .shape-selector {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            margin-bottom: 20px;
        }
        
        .info-container h3 {
            font-size: 1.5rem;
            margin-bottom: 10px;
            color: var(--secondary-color);
        }
        
        .dimensions, .calculations {
            margin-top: 20px;
            padding: 12px;
            border-radius: 8px;
            background: linear-gradient(45deg, rgba(77, 77, 222, 0.15), rgba(255, 107, 107, 0.15));
        }
        
        .loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.3);
            z-index: 10;
            color: white;
            font-size: 1.2rem;
            border-radius: 15px;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid white;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .face-area {
            position: absolute;
            padding: 4px 8px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 4px;
            font-size: 0.8rem;
            z-index: 5;
            pointer-events: none;
        }
        
        /* Net visualization styles */
        .net-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            display: none;
            background-color: rgba(0, 0, 0, 0.2);
        }
        
        .fold-animation-btn {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 8px 12px;
            cursor: pointer;
            font-weight: 600;
            z-index: 10;
            display: none;
        }
        
        .fold-animation-btn:hover {
            background-color: var(--secondary-color);
        }
        
        .net-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 0.85rem;
            max-width: 200px;
            display: none;
            z-index: 6;
        }
        
        .face-label {
            position: absolute;
            padding: 2px 6px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 3px;
            font-size: 0.7rem;
            pointer-events: none;
        }
        
        @media (max-width: 640px) {
            .title {
                font-size: 1.8rem;
            }
            
            .canvas-container {
                height: 280px;
            }
            
            .shape-btn {
                font-size: 0.9rem;
                padding: 8px 12px;
            }
            
            .card {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="title">Simulasi Bangun Ruang 3D</h1>
        
        <div class="grid">
            <!-- 3D Visualization -->
            <div class="card">
                <h2 style="text-align: center; margin-bottom: 15px;">Visualisasi 3D</h2>
                <div class="canvas-container" id="canvas-container">
                    <div id="scene"></div>
                    <div class="rotate-info">Geser untuk memutar | Scroll untuk zoom</div>
                    <div id="surface-info" class="surface-info"></div>
                    <div id="net-info" class="net-info"></div>
                    <button id="fold-animation-btn" class="fold-animation-btn">Lipat/Buka Jaring-jaring</button>
                    <div id="loading" class="loading">
                        <div class="spinner"></div>
                        <span>Memuat...</span>
                    </div>
                </div>
                
                <div class="controls">
                    <div class="slider-container" id="dimension-slider-1-container">
                        <label id="dimension-1-label">Panjang Sisi: <span id="dimension-1-value">1</span></label>
                        <input type="range" min="0.5" max="3" step="0.1" value="1" class="slider" id="dimension-1">
                    </div>
                    
                    <div class="slider-container" id="dimension-slider-2-container">
                        <label id="dimension-2-label">Lebar: <span id="dimension-2-value">1</span></label>
                        <input type="range" min="0.5" max="3" step="0.1" value="1" class="slider" id="dimension-2">
                    </div>
                    
                    <div class="slider-container" id="dimension-slider-3-container">
                        <label id="dimension-3-label">Tinggi: <span id="dimension-3-value">1</span></label>
                        <input type="range" min="0.5" max="3" step="0.1" value="1" class="slider" id="dimension-3">
                    </div>
                    
                    <div class="slider-container" id="sides-slider-container" style="display: none;">
                        <label id="sides-label">Jumlah Sisi: <span id="sides-value">3</span></label>
                        <input type="range" min="3" max="10" step="1" value="3" class="slider" id="sides-slider">
                    </div>
                </div>
                
                <div class="toggle-container">
                    <div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="toggle-axes" checked>
                            <span class="toggle-slider"></span>
                        </label>
                        <span class="toggle-label">Sumbu Koordinat</span>
                    </div>
                    
                    <div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="toggle-surface">
                            <span class="toggle-slider"></span>
                        </label>
                        <span class="toggle-label">Visualisasi Luas</span>
                    </div>
                    
                    <div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="toggle-net">
                            <span class="toggle-slider"></span>
                        </label>
                        <span class="toggle-label">Jaring-jaring</span>
                    </div>
                </div>
            </div>
            
            <!-- Formulas and Information -->
            <div class="card">
                <h2 style="text-align: center; margin-bottom: 15px;">Rumus & Informasi</h2>
                
                <div class="shape-selector">
                    <button class="shape-btn active" data-shape="cube">Kubus</button>
                    <button class="shape-btn" data-shape="cuboid">Balok</button>
                    <button class="shape-btn" data-shape="cylinder">Tabung</button>
                    <button class="shape-btn" data-shape="cone">Kerucut</button>
                    <button class="shape-btn" data-shape="sphere">Bola</button>
                    <button class="shape-btn" data-shape="prism">Prisma</button>
                    <button class="shape-btn" data-shape="pyramid">Limas</button>
                </div>
                
                <div class="info-container">
                    <h3 id="shape-name">Kubus</h3>
                    <p id="shape-description">Kubus adalah bangun ruang dengan 6 sisi berbentuk persegi yang kongruen (sama dan sebangun).</p>
                    
                    <div class="formula-box">
                        <h4 style="font-weight: 600; margin-bottom: 8px;">Luas Permukaan:</h4>
                        <div id="surface-area-formula" class="my-2">
                            \[ L = 6 \times s^2 \]
                        </div>
                        <p id="surface-area-explanation">
                            Luas permukaan kubus adalah jumlah luas keenam sisinya. Karena semua sisinya sama, maka rumusnya adalah 6 dikali luas 1 sisi, yaitu \(6 \times s^2\).
                        </p>
                    </div>
                    
                    <div class="formula-box" style="margin-top: 15px;">
                        <h4 style="font-weight: 600; margin-bottom: 8px;">Volume:</h4>
                        <div id="volume-formula" class="my-2">
                            \[ V = s^3 \]
                        </div>
                        <p id="volume-explanation">
                            Volume kubus adalah hasil kali panjang, lebar, dan tingginya. Karena semua sisinya sama panjang, maka rumusnya adalah \(s \times s \times s = s^3\).
                        </p>
                    </div>
                    
                    <div class="dimensions">
                        <h4 style="font-weight: 600; margin-bottom: 8px;">Dimensi Saat Ini:</h4>
                        <p id="current-dimensions">Sisi (s) = 1 unit</p>
                    </div>
                    
                    <div class="calculations">
                        <h4 style="font-weight: 600; margin-bottom: 8px;">Hasil Perhitungan:</h4>
                        <p id="current-surface-area">Luas Permukaan = 6 × 1² = 6 unit²</p>
                        <p id="current-volume">Volume = 1³ = 1 unit³</p>
                    </div>
                </div>
            </div>
        </div>
        
        <div style="text-align: center; margin-top: 20px; opacity: 0.8; font-size: 0.9rem;">
            <p>Klik pada tombol bangun ruang yang berbeda untuk mempelajari rumus-rumusnya.</p>
            <p>Gunakan slider untuk mengubah dimensi dan melihat perubahan pada luas permukaan dan volume.</p>
        </div>
    </div>

    <script>
        // MathJax already initialized in head
        
        // 3D Scene Setup
        let scene, camera, renderer, controls, currentShape, axesHelper, surfaceAreaVisualization = null;
        let surfaceVisualizationMode = false;
        let axesMode = true;
        let netVisualizationMode = false;
        let netVisualization = null;
        let animationInProgress = false;
        let folded = true;
        
        let dimensions = {
            dim1: 1,
            dim2: 1,
            dim3: 1,
            sides: 3
        };
        
        const shapeData = {
            cube: {
                name: "Kubus",
                nameEn: "Cube",
                description: "Kubus adalah bangun ruang dengan 6 sisi berbentuk persegi yang kongruen (sama dan sebangun).",
                surfaceAreaFormula: "\\[ L = 6 \\times s^2 \\]",
                surfaceAreaExplanation: "Luas permukaan kubus adalah jumlah luas keenam sisinya. Karena semua sisinya sama, maka rumusnya adalah 6 dikali luas 1 sisi, yaitu \\(6 \\times s^2\\).",
                volumeFormula: "\\[ V = s^3 \\]",
                volumeExplanation: "Volume kubus adalah hasil kali panjang, lebar, dan tingginya. Karena semua sisinya sama panjang, maka rumusnya adalah \\(s \\times s \\times s = s^3\\).",
                dimensionLabels: ["Panjang Sisi (s)"],
                calculateSurfaceArea: (s) => 6 * s * s,
                calculateVolume: (s) => s * s * s,
                create: (s) => new THREE.BoxGeometry(s, s, s),
                dimensions: ["dim1"],
                needsSides: false,
                color: 0xFF6B6B,
                faceAreas: (s) => [
                    { face: "Depan", area: s*s, position: [0, 0, s/2], normal: [0, 0, 1] },
                    { face: "Belakang", area: s*s, position: [0, 0, -s/2], normal: [0, 0, -1] },
                    { face: "Atas", area: s*s, position: [0, s/2, 0], normal: [0, 1, 0] },
                    { face: "Bawah", area: s*s, position: [0, -s/2, 0], normal: [0, -1, 0] },
                    { face: "Kanan", area: s*s, position: [s/2, 0, 0], normal: [1, 0, 0] },
                    { face: "Kiri", area: s*s, position: [-s/2, 0, 0], normal: [-1, 0, 0] }
                ],
                createNet: (s) => {
                    // Create a truly 2D net for cube
                    const group = new THREE.Group();
                    
                    // Create materials for each face with different colors
                    const materials = [
                        new THREE.MeshBasicMaterial({ color: 0xFF6B6B, side: THREE.DoubleSide, transparent: true, opacity: 0.9 }), // Front - red
                        new THREE.MeshBasicMaterial({ color: 0x4ECDC4, side: THREE.DoubleSide, transparent: true, opacity: 0.9 }), // Back - teal
                        new THREE.MeshBasicMaterial({ color: 0xFFD166, side: THREE.DoubleSide, transparent: true, opacity: 0.9 }), // Top - yellow
                        new THREE.MeshBasicMaterial({ color: 0xF25F5C, side: THREE.DoubleSide, transparent: true, opacity: 0.9 }), // Bottom - salmon
                        new THREE.MeshBasicMaterial({ color: 0x5D5CDE, side: THREE.DoubleSide, transparent: true, opacity: 0.9 }), // Right - purple
                        new THREE.MeshBasicMaterial({ color: 0x247BA0, side: THREE.DoubleSide, transparent: true, opacity: 0.9 })  // Left - blue
                    ];
                    
                    // Common geometry for all faces
                    const faceGeometry = new THREE.PlaneGeometry(s, s);
                    
                    // All faces positioned in a cross pattern on a single plane
                    // Bottom face (central)
                    const bottomFace = new THREE.Mesh(faceGeometry, materials[3]);
                    bottomFace.position.set(0, 0, 0);
                    bottomFace.rotation.x = Math.PI/2;
                    bottomFace.originalPosition = new THREE.Vector3(0, 0, 0);
                    bottomFace.targetPosition = new THREE.Vector3(0, -s/2, 0);
                    bottomFace.originalRotation = new THREE.Euler(Math.PI/2, 0, 0);
                    bottomFace.targetRotation = new THREE.Euler(Math.PI/2, 0, 0);
                    group.add(bottomFace);
                    
                    // Front face
                    const frontFace = new THREE.Mesh(faceGeometry, materials[0]);
                    frontFace.position.set(0, -s, 0);
                    frontFace.rotation.x = 0;
                    frontFace.originalPosition = new THREE.Vector3(0, -s, 0);
                    frontFace.targetPosition = new THREE.Vector3(0, 0, s/2);
                    frontFace.originalRotation = new THREE.Euler(0, 0, 0);
                    frontFace.targetRotation = new THREE.Euler(0, 0, 0);
                    group.add(frontFace);
                    
                    // Back face
                    const backFace = new THREE.Mesh(faceGeometry, materials[1]);
                    backFace.position.set(0, s, 0);
                    backFace.rotation.x = 0;
                    backFace.rotation.y = Math.PI;
                    backFace.originalPosition = new THREE.Vector3(0, s, 0);
                    backFace.targetPosition = new THREE.Vector3(0, 0, -s/2);
                    backFace.originalRotation = new THREE.Euler(0, Math.PI, 0);
                    backFace.targetRotation = new THREE.Euler(0, Math.PI, 0);
                    group.add(backFace);
                    
                    // Right face
                    const rightFace = new THREE.Mesh(faceGeometry, materials[4]);
                    rightFace.position.set(s, 0, 0);
                    rightFace.rotation.y = 0;
                    rightFace.originalPosition = new THREE.Vector3(s, 0, 0);
                    rightFace.targetPosition = new THREE.Vector3(s/2, 0, 0);
                    rightFace.originalRotation = new THREE.Euler(0, 0, 0);
                    rightFace.targetRotation = new THREE.Euler(0, Math.PI/2, 0);
                    group.add(rightFace);
                    
                    // Left face
                    const leftFace = new THREE.Mesh(faceGeometry, materials[5]);
                    leftFace.position.set(-s, 0, 0);
                    leftFace.rotation.y = 0;
                    leftFace.originalPosition = new THREE.Vector3(-s, 0, 0);
                    leftFace.targetPosition = new THREE.Vector3(-s/2, 0, 0);
                    leftFace.originalRotation = new THREE.Euler(0, 0, 0);
                    leftFace.targetRotation = new THREE.Euler(0, -Math.PI/2, 0);
                    group.add(leftFace);
                    
                    // Top face
                    const topFace = new THREE.Mesh(faceGeometry, materials[2]);
                    topFace.position.set(0, -2*s, 0);
                    topFace.rotation.x = 0;
                    topFace.originalPosition = new THREE.Vector3(0, -2*s, 0);
                    topFace.targetPosition = new THREE.Vector3(0, s/2, 0);
                    topFace.originalRotation = new THREE.Euler(0, 0, 0);
                    topFace.targetRotation = new THREE.Euler(-Math.PI/2, 0, 0);
                    group.add(topFace);
                    
                    // Add face labels
                    const faceLabels = [
                        { text: "Depan", position: frontFace.position.clone() },
                        { text: "Belakang", position: backFace.position.clone() },
                        { text: "Atas", position: topFace.position.clone() },
                        { text: "Bawah", position: bottomFace.position.clone() },
                        { text: "Kanan", position: rightFace.position.clone() },
                        { text: "Kiri", position: leftFace.position.clone() }
                    ];
                    
                    group.faceLabels = faceLabels;
                    
                    // Add edges
                    const edges = new THREE.Group();
                    const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
                    
                    // Helper function to create edge
                    function createEdge(p1, p2) {
                        const points = [];
                        points.push(new THREE.Vector3(p1[0], p1[1], p1[2]));
                        points.push(new THREE.Vector3(p2[0], p2[1], p2[2]));
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        return new THREE.Line(geometry, lineMaterial);
                    }
                    
                    // Add visible edges for each face
                    const halfS = s/2;
                    
                    // Bottom face edges
                    edges.add(createEdge([-halfS, 0, -halfS], [halfS, 0, -halfS]));
                    edges.add(createEdge([halfS, 0, -halfS], [halfS, 0, halfS]));
                    edges.add(createEdge([halfS, 0, halfS], [-halfS, 0, halfS]));
                    edges.add(createEdge([-halfS, 0, halfS], [-halfS, 0, -halfS]));
                    
                    // Front face edges
                    edges.add(createEdge([-halfS, -s-halfS, 0], [halfS, -s-halfS, 0]));
                    edges.add(createEdge([halfS, -s-halfS, 0], [halfS, -s+halfS, 0]));
                    edges.add(createEdge([halfS, -s+halfS, 0], [-halfS, -s+halfS, 0]));
                    edges.add(createEdge([-halfS, -s+halfS, 0], [-halfS, -s-halfS, 0]));
                    
                    // Back face edges
                    edges.add(createEdge([-halfS, s-halfS, 0], [halfS, s-halfS, 0]));
                    edges.add(createEdge([halfS, s-halfS, 0], [halfS, s+halfS, 0]));
                    edges.add(createEdge([halfS, s+halfS, 0], [-halfS, s+halfS, 0]));
                    edges.add(createEdge([-halfS, s+halfS, 0], [-halfS, s-halfS, 0]));
                    
                    // Right face edges
                    edges.add(createEdge([s-halfS, -halfS, 0], [s+halfS, -halfS, 0]));
                    edges.add(createEdge([s+halfS, -halfS, 0], [s+halfS, halfS, 0]));
                    edges.add(createEdge([s+halfS, halfS, 0], [s-halfS, halfS, 0]));
                    edges.add(createEdge([s-halfS, halfS, 0], [s-halfS, -halfS, 0]));
                    
                    // Left face edges
                    edges.add(createEdge([-s-halfS, -halfS, 0], [-s+halfS, -halfS, 0]));
                    edges.add(createEdge([-s+halfS, -halfS, 0], [-s+halfS, halfS, 0]));
                    edges.add(createEdge([-s+halfS, halfS, 0], [-s-halfS, halfS, 0]));
                    edges.add(createEdge([-s-halfS, halfS, 0], [-s-halfS, -halfS, 0]));
                    
                    // Top face edges
                    edges.add(createEdge([-halfS, -2*s-halfS, 0], [halfS, -2*s-halfS, 0]));
                    edges.add(createEdge([halfS, -2*s-halfS, 0], [halfS, -2*s+halfS, 0]));
                    edges.add(createEdge([halfS, -2*s+halfS, 0], [-halfS, -2*s+halfS, 0]));
                    edges.add(createEdge([-halfS, -2*s+halfS, 0], [-halfS, -2*s-halfS, 0]));
                    
                    // Connection lines
                    // Bottom to front
                    edges.add(createEdge([0, 0, halfS], [0, -s+halfS, 0]));
                    // Bottom to back
                    edges.add(createEdge([0, 0, -halfS], [0, s-halfS, 0]));
                    // Bottom to right
                    edges.add(createEdge([halfS, 0, 0], [s-halfS, 0, 0]));
                    // Bottom to left
                    edges.add(createEdge([-halfS, 0, 0], [-s+halfS, 0, 0]));
                    // Front to top
                    edges.add(createEdge([0, -s-halfS, 0], [0, -2*s+halfS, 0]));
                    
                    group.add(edges);
                    
                    // Position group to center it
                    group.position.set(0, 0, 0);
                    
                    return group;
                }
            },
            cuboid: {
                name: "Balok",
                nameEn: "Cuboid",
                description: "Balok adalah bangun ruang yang memiliki 6 sisi berbentuk persegi panjang dengan minimal 3 pasang sisi yang kongruen.",
                surfaceAreaFormula: "\\[ L = 2 (p \\times l + p \\times t + l \\times t) \\]",
                surfaceAreaExplanation: "Luas permukaan balok adalah jumlah luas keenam sisinya. Karena terdiri dari 3 pasang sisi yang sama, maka rumusnya adalah \\(2 (p \\times l + p \\times t + l \\times t)\\).",
                volumeFormula: "\\[ V = p \\times l \\times t \\]",
                volumeExplanation: "Volume balok adalah hasil kali panjang, lebar, dan tingginya, yaitu \\(p \\times l \\times t\\).",
                dimensionLabels: ["Panjang (p)", "Lebar (l)", "Tinggi (t)"],
                calculateSurfaceArea: (p, l, t) => 2 * ((p * l) + (p * t) + (l * t)),
                calculateVolume: (p, l, t) => p * l * t,
                create: (p, l, t) => new THREE.BoxGeometry(p, t, l),
                dimensions: ["dim1", "dim2", "dim3"],
                needsSides: false,
                color: 0x4ECDC4,
                faceAreas: (p, l, t) => [
                    { face: "Depan", area: p*t, position: [0, 0, l/2], normal: [0, 0, 1] },
                    { face: "Belakang", area: p*t, position: [0, 0, -l/2], normal: [0, 0, -1] },
                    { face: "Atas", area: p*l, position: [0, t/2, 0], normal: [0, 1, 0] },
                    { face: "Bawah", area: p*l, position: [0, -t/2, 0], normal: [0, -1, 0] },
                    { face: "Kanan", area: l*t, position: [p/2, 0, 0], normal: [1, 0, 0] },
                    { face: "Kiri", area: l*t, position: [-p/2, 0, 0], normal: [-1, 0, 0] }
                ],
                createNet: (p, l, t) => {
                    // Create a truly 2D net for cuboid
                    const group = new THREE.Group();
                    
                    // Create materials for each face with different colors
                    const materials = [
                        new THREE.MeshBasicMaterial({ color: 0xFF6B6B, side: THREE.DoubleSide, transparent: true, opacity: 0.9 }), // Front - red
                        new THREE.MeshBasicMaterial({ color: 0x4ECDC4, side: THREE.DoubleSide, transparent: true, opacity: 0.9 }), // Back - teal
                        new THREE.MeshBasicMaterial({ color: 0xFFD166, side: THREE.DoubleSide, transparent: true, opacity: 0.9 }), // Top - yellow
                        new THREE.MeshBasicMaterial({ color: 0xF25F5C, side: THREE.DoubleSide, transparent: true, opacity: 0.9 }), // Bottom - salmon
                        new THREE.MeshBasicMaterial({ color: 0x5D5CDE, side: THREE.DoubleSide, transparent: true, opacity: 0.9 }), // Right - purple
                        new THREE.MeshBasicMaterial({ color: 0x247BA0, side: THREE.DoubleSide, transparent: true, opacity: 0.9 })  // Left - blue
                    ];
                    
                    // Bottom face (central)
                    const bottomGeometry = new THREE.PlaneGeometry(p, l);
                    const bottomFace = new THREE.Mesh(bottomGeometry, materials[3]);
                    bottomFace.position.set(0, 0, 0);
                    bottomFace.rotation.x = Math.PI/2;
                    bottomFace.originalPosition = new THREE.Vector3(0, 0, 0);
                    bottomFace.targetPosition = new THREE.Vector3(0, -t/2, 0);
                    bottomFace.originalRotation = new THREE.Euler(Math.PI/2, 0, 0);
                    bottomFace.targetRotation = new THREE.Euler(Math.PI/2, 0, 0);
                    group.add(bottomFace);
                    
                    // Front face
                    const frontGeometry = new THREE.PlaneGeometry(p, t);
                    const frontFace = new THREE.Mesh(frontGeometry, materials[0]);
                    frontFace.position.set(0, -l/2-t/2, 0);
                    frontFace.originalPosition = new THREE.Vector3(0, -l/2-t/2, 0);
                    frontFace.targetPosition = new THREE.Vector3(0, 0, l/2);
                    frontFace.originalRotation = new THREE.Euler(0, 0, 0);
                    frontFace.targetRotation = new THREE.Euler(0, 0, 0);
                    group.add(frontFace);
                    
                    // Back face
                    const backGeometry = new THREE.PlaneGeometry(p, t);
                    const backFace = new THREE.Mesh(backGeometry, materials[1]);
                    backFace.position.set(0, l/2+t/2, 0);
                    backFace.rotation.y = Math.PI;
                    backFace.originalPosition = new THREE.Vector3(0, l/2+t/2, 0);
                    backFace.targetPosition = new THREE.Vector3(0, 0, -l/2);
                    backFace.originalRotation = new THREE.Euler(0, Math.PI, 0);
                    backFace.targetRotation = new THREE.Euler(0, Math.PI, 0);
                    group.add(backFace);
                    
                    // Right face
                    const rightGeometry = new THREE.PlaneGeometry(l, t);
                    const rightFace = new THREE.Mesh(rightGeometry, materials[4]);
                    rightFace.position.set(p/2+l/2, 0, 0);
                    rightFace.originalPosition = new THREE.Vector3(p/2+l/2, 0, 0);
                    rightFace.targetPosition = new THREE.Vector3(p/2, 0, 0);
                    rightFace.originalRotation = new THREE.Euler(0, 0, 0);
                    rightFace.targetRotation = new THREE.Euler(0, Math.PI/2, 0);
                    group.add(rightFace);
                    
                    // Left face
                    const leftGeometry = new THREE.PlaneGeometry(l, t);
                    const leftFace = new THREE.Mesh(leftGeometry, materials[5]);
                    leftFace.position.set(-p/2-l/2, 0, 0);
                    leftFace.originalPosition = new THREE.Vector3(-p/2-l/2, 0, 0);
                    leftFace.targetPosition = new THREE.Vector3(-p/2, 0, 0);
                    leftFace.originalRotation = new THREE.Euler(0, 0, 0);
                    leftFace.targetRotation = new THREE.Euler(0, -Math.PI/2, 0);
                    group.add(leftFace);
                    
                    // Top face
                    const topGeometry = new THREE.PlaneGeometry(p, l);
                    const topFace = new THREE.Mesh(topGeometry, materials[2]);
                    topFace.position.set(0, -l/2-t-l/2, 0);
                    topFace.originalPosition = new THREE.Vector3(0, -l/2-t-l/2, 0);
                    topFace.targetPosition = new THREE.Vector3(0, t/2, 0);
                    topFace.originalRotation = new THREE.Euler(0, 0, 0);
                    topFace.targetRotation = new THREE.Euler(-Math.PI/2, 0, 0);
                    group.add(topFace);
                    
                    // Add face labels
                    const faceLabels = [
                        { text: "Depan", position: frontFace.position.clone() },
                        { text: "Belakang", position: backFace.position.clone() },
                        { text: "Atas", position: topFace.position.clone() },
                        { text: "Bawah", position: bottomFace.position.clone() },
                        { text: "Kanan", position: rightFace.position.clone() },
                        { text: "Kiri", position: leftFace.position.clone() }
                    ];
                    
                    group.faceLabels = faceLabels;
                    
                    // Add edges
                    const edges = new THREE.Group();
                    const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
                    
                    // Helper function to create edge
                    function createEdge(p1, p2) {
                        const points = [];
                        points.push(new THREE.Vector3(p1[0], p1[1], p1[2]));
                        points.push(new THREE.Vector3(p2[0], p2[1], p2[2]));
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        return new THREE.Line(geometry, lineMaterial);
                    }
                    
                    // Add edges for each face and connections between them
                    // (Simplified for brevity)
                    
                    group.add(edges);
                    
                    return group;
                }
            },
            cylinder: {
                name: "Tabung",
                nameEn: "Cylinder",
                description: "Tabung adalah bangun ruang yang dibatasi oleh dua bidang berbentuk lingkaran yang sejajar dan kongruen dan sebuah bidang lengkung.",
                surfaceAreaFormula: "\\[ L = 2 \\pi r^2 + 2 \\pi r t \\]",
                surfaceAreaExplanation: "Luas permukaan tabung adalah luas kedua alas lingkaran (\\(2 \\pi r^2\\)) ditambah luas selimut (\\(2 \\pi r t\\)).",
                volumeFormula: "\\[ V = \\pi r^2 t \\]",
                volumeExplanation: "Volume tabung adalah luas alas dikali tinggi, yaitu \\(\\pi r^2 \\times t\\).",
                dimensionLabels: ["Jari-jari (r)", "Tinggi (t)"],
                calculateSurfaceArea: (r, t) => 2 * Math.PI * r * r + 2 * Math.PI * r * t,
                calculateVolume: (r, t) => Math.PI * r * r * t,
                create: (r, t) => new THREE.CylinderGeometry(r, r, t, 32),
                dimensions: ["dim1", "dim3"],
                needsSides: false,
                color: 0xFFD166,
                faceAreas: (r, t) => [
                    { face: "Alas Atas", area: Math.PI * r * r, position: [0, t/2, 0], normal: [0, 1, 0] },
                    { face: "Alas Bawah", area: Math.PI * r * r, position: [0, -t/2, 0], normal: [0, -1, 0] },
                    { face: "Selimut", area: 2 * Math.PI * r * t, position: [r, 0, 0], normal: [1, 0, 0] }
                ],
                createNet: (r, t) => {
                    // Create a truly 2D net for cylinder
                    const group = new THREE.Group();
                    
                    // Create materials for each face with different colors
                    const materials = [
                        new THREE.MeshBasicMaterial({ color: 0xFFD166, side: THREE.DoubleSide, transparent: true, opacity: 0.9 }), // Selimut
                        new THREE.MeshBasicMaterial({ color: 0xFF6B6B, side: THREE.DoubleSide, transparent: true, opacity: 0.9 }), // Top
                        new THREE.MeshBasicMaterial({ color: 0x4ECDC4, side: THREE.DoubleSide, transparent: true, opacity: 0.9 })  // Bottom
                    ];
                    
                    // Create selimut (curved surface) as a flat rectangle
                    const circumference = 2 * Math.PI * r;
                    const selimutGeometry = new THREE.PlaneGeometry(circumference, t);
                    const selimut = new THREE.Mesh(selimutGeometry, materials[0]);
                    selimut.position.set(0, 0, 0);
                    selimut.originalPosition = new THREE.Vector3(0, 0, 0);
                    selimut.targetPosition = new THREE.Vector3(0, 0, 0);
                    // In 3D, this would be wrapped around, but we keep it flat in 2D
                    selimut.originalRotation = new THREE.Euler(0, 0, 0);
                    selimut.targetRotation = new THREE.Euler(0, 0, 0);
                    group.add(selimut);
                    
                    // Create bottom circle
                    const bottomGeometry = new THREE.CircleGeometry(r, 32);
                    const bottomCircle = new THREE.Mesh(bottomGeometry, materials[2]);
                    bottomCircle.position.set(0, -t-r, 0);
                    bottomCircle.originalPosition = new THREE.Vector3(0, -t-r, 0);
                    bottomCircle.targetPosition = new THREE.Vector3(0, -t/2, 0);
                    bottomCircle.originalRotation = new THREE.Euler(0, 0, 0);
                    bottomCircle.targetRotation = new THREE.Euler(Math.PI/2, 0, 0);
                    group.add(bottomCircle);
                    
                    // Create top circle
                    const topGeometry = new THREE.CircleGeometry(r, 32);
                    const topCircle = new THREE.Mesh(topGeometry, materials[1]);
                    topCircle.position.set(0, t+r, 0);
                    topCircle.originalPosition = new THREE.Vector3(0, t+r, 0);
                    topCircle.targetPosition = new THREE.Vector3(0, t/2, 0);
                    topCircle.originalRotation = new THREE.Euler(0, 0, 0);
                    topCircle.targetRotation = new THREE.Euler(-Math.PI/2, 0, 0);
                    group.add(topCircle);
                    
                    // Add face labels
                    const faceLabels = [
                        { text: "Selimut", position: selimut.position.clone() },
                        { text: "Alas Atas", position: topCircle.position.clone() },
                        { text: "Alas Bawah", position: bottomCircle.position.clone() }
                    ];
                    
                    group.faceLabels = faceLabels;
                    
                    // Add edges
                    const edges = new THREE.Group();
                    const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
                    
                    // Helper function to create edge
                    function createEdge(p1, p2) {
                        const points = [];
                        points.push(new THREE.Vector3(p1[0], p1[1], p1[2]));
                        points.push(new THREE.Vector3(p2[0], p2[1], p2[2]));
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        return new THREE.Line(geometry, lineMaterial);
                    }
                    
                    // Add edges for the selimut rectangle
                    const halfWidth = circumference / 2;
                    const halfHeight = t / 2;
                    
                    edges.add(createEdge([-halfWidth, -halfHeight, 0], [halfWidth, -halfHeight, 0]));
                    edges.add(createEdge([halfWidth, -halfHeight, 0], [halfWidth, halfHeight, 0]));
                    edges.add(createEdge([halfWidth, halfHeight, 0], [-halfWidth, halfHeight, 0]));
                    edges.add(createEdge([-halfWidth, halfHeight, 0], [-halfWidth, -halfHeight, 0]));
                    
                    // Add connection lines
                    edges.add(createEdge([0, -halfHeight, 0], [0, -t-r, 0]));
                    edges.add(createEdge([0, halfHeight, 0], [0, t+r, 0]));
                    
                    // Add circles for circles
                    const circlePoints = [];
                    for (let i = 0; i <= 32; i++) {
                        const angle = (i / 32) * Math.PI * 2;
                        circlePoints.push(
                            new THREE.Vector3(Math.cos(angle) * r, Math.sin(angle) * r, 0)
                        );
                    }
                    
                    const topCircleGeometry = new THREE.BufferGeometry().setFromPoints(circlePoints);
                    const topCircleLine = new THREE.Line(topCircleGeometry, lineMaterial);
                    topCircleLine.position.copy(topCircle.position);
                    
                    const bottomCircleGeometry = new THREE.BufferGeometry().setFromPoints(circlePoints);
                    const bottomCircleLine = new THREE.Line(bottomCircleGeometry, lineMaterial);
                    bottomCircleLine.position.copy(bottomCircle.position);
                    
                    edges.add(topCircleLine);
                    edges.add(bottomCircleLine);
                    
                    group.add(edges);
                    
                    return group;
                }
            },
            cone: {
                name: "Kerucut",
                nameEn: "Cone",
                description: "Kerucut adalah bangun ruang yang alasnya berbentuk lingkaran dan memiliki satu titik puncak.",
                surfaceAreaFormula: "\\[ L = \\pi r^2 + \\pi r s \\]",
                surfaceAreaExplanation: "Luas permukaan kerucut adalah luas alas (\\(\\pi r^2\\)) ditambah luas selimut (\\(\\pi r s\\)), dimana \\(s\\) adalah panjang garis pelukis/ apotema yang dapat dihitung dengan \\(s = \\sqrt{r^2 + t^2}\\).",
                volumeFormula: "\\[ V = \\frac{1}{3} \\pi r^2 t \\]",
                volumeExplanation: "Volume kerucut adalah sepertiga dari volume tabung dengan alas dan tinggi yang sama, yaitu \\(\\frac{1}{3} \\pi r^2 t\\).",
                dimensionLabels: ["Jari-jari (r)", "Tinggi (t)"],
                calculateSurfaceArea: (r, t) => {
                    const s = Math.sqrt(r*r + t*t); // garis pelukis/apotema
                    return Math.PI * r * r + Math.PI * r * s;
                },
                calculateVolume: (r, t) => (1/3) * Math.PI * r * r * t,
                create: (r, t) => new THREE.ConeGeometry(r, t, 32),
                dimensions: ["dim1", "dim3"],
                needsSides: false,
                color: 0xF25F5C,
                faceAreas: (r, t) => {
                    const s = Math.sqrt(r*r + t*t); // garis pelukis
                    return [
                        { face: "Alas", area: Math.PI * r * r, position: [0, -t/2, 0], normal: [0, -1, 0] },
                        { face: "Selimut", area: Math.PI * r * s, position: [r/2, 0, 0], normal: [r, t, 0] }
                    ];
                },
                createNet: (r, t) => {
                    // Create a truly 2D net for cone
                    const group = new THREE.Group();
                    
                    // Calculate slant height (s)
                    const s = Math.sqrt(r*r + t*t);
                    
                    // Create materials for each face with different colors
                    const materials = [
                        new THREE.MeshBasicMaterial({ color: 0xF25F5C, side: THREE.DoubleSide, transparent: true, opacity: 0.9 }), // Selimut
                        new THREE.MeshBasicMaterial({ color: 0x4ECDC4, side: THREE.DoubleSide, transparent: true, opacity: 0.9 })  // Base
                    ];
                    
                    // Create base circle
                    const baseGeometry = new THREE.CircleGeometry(r, 32);
                    const baseCircle = new THREE.Mesh(baseGeometry, materials[1]);
                    baseCircle.position.set(0, 0, 0);
                    baseCircle.originalPosition = new THREE.Vector3(0, 0, 0);
                    baseCircle.targetPosition = new THREE.Vector3(0, -t/2, 0);
                    baseCircle.originalRotation = new THREE.Euler(0, 0, 0);
                    baseCircle.targetRotation = new THREE.Euler(Math.PI/2, 0, 0);
                    group.add(baseCircle);
                    
                    // Create selimut (curved surface) as a sector of a circle
                    // For the 2D net, we'll use a simple sector
                    const sectorAngle = 2 * Math.PI * r / s;
                    const segments = 32;
                    const sectorVertices = [];
                    
                    // Add center point
                    sectorVertices.push(new THREE.Vector3(0, 0, 0));
                    
                    // Add points along the arc
                    for (let i = 0; i <= segments; i++) {
                        const angle = (i / segments) * sectorAngle - sectorAngle/2;
                        sectorVertices.push(
                            new THREE.Vector3(Math.cos(angle) * s, Math.sin(angle) * s, 0)
                        );
                    }
                    
                    const sectorGeometry = new THREE.BufferGeometry();
                    sectorGeometry.setFromPoints(sectorVertices);
                    const indices = [];
                    
                    // Create triangles - center point to each pair of points on arc
                    for (let i = 1; i < sectorVertices.length - 1; i++) {
                        indices.push(0, i, i + 1);
                    }
                    
                    sectorGeometry.setIndex(indices);
                    sectorGeometry.computeVertexNormals();
                    
                    const selimut = new THREE.Mesh(sectorGeometry, materials[0]);
                    selimut.position.set(0, -2*r, 0);
                    selimut.originalPosition = new THREE.Vector3(0, -2*r, 0);
                    selimut.targetPosition = new THREE.Vector3(0, 0, 0);
                    selimut.originalRotation = new THREE.Euler(0, 0, 0);
                    selimut.targetRotation = new THREE.Euler(0, 0, 0);
                    group.add(selimut);
                    
                    // Add face labels
                    const faceLabels = [
                        { text: "Selimut", position: selimut.position.clone().add(new THREE.Vector3(0, -s/2, 0)) },
                        { text: "Alas", position: baseCircle.position.clone() }
                    ];
                    
                    group.faceLabels = faceLabels;
                    
                    // Add edges
                    const edges = new THREE.Group();
                    const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
                    
                    // Helper function to create edge
                    function createEdge(p1, p2) {
                        const points = [];
                        points.push(new THREE.Vector3(p1[0], p1[1], p1[2]));
                        points.push(new THREE.Vector3(p2[0], p2[1], p2[2]));
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        return new THREE.Line(geometry, lineMaterial);
                    }
                    
                    // Add circle for base
                    const circlePoints = [];
                    for (let i = 0; i <= 32; i++) {
                        const angle = (i / 32) * Math.PI * 2;
                        circlePoints.push(
                            new THREE.Vector3(Math.cos(angle) * r, Math.sin(angle) * r, 0)
                        );
                    }
                    
                    const circleGeometry = new THREE.BufferGeometry().setFromPoints(circlePoints);
                    const circle = new THREE.Line(circleGeometry, lineMaterial);
                    circle.position.copy(baseCircle.position);
                    edges.add(circle);
                    
                    // Add edges for sector
                    const sectorEdgePoints = [];
                    for (let i = 0; i <= segments; i++) {
                        const angle = (i / segments) * sectorAngle - sectorAngle/2;
                        sectorEdgePoints.push(
                            new THREE.Vector3(Math.cos(angle) * s, Math.sin(angle) * s, 0)
                        );
                    }
                    
                    const sectorEdgeGeometry = new THREE.BufferGeometry().setFromPoints(sectorEdgePoints);
                    const sectorEdge = new THREE.Line(sectorEdgeGeometry, lineMaterial);
                    sectorEdge.position.copy(selimut.position);
                    edges.add(sectorEdge);
                    
                    // Add lines from center to endpoints
                    edges.add(createEdge(
                        [selimut.position.x, selimut.position.y, selimut.position.z],
                        [selimut.position.x + Math.cos(-sectorAngle/2) * s, selimut.position.y + Math.sin(-sectorAngle/2) * s, 0]
                    ));
                    
                    edges.add(createEdge(
                        [selimut.position.x, selimut.position.y, selimut.position.z],
                        [selimut.position.x + Math.cos(sectorAngle/2) * s, selimut.position.y + Math.sin(sectorAngle/2) * s, 0]
                    ));
                    
                    // Add connection line to base
                    edges.add(createEdge(
                        [selimut.position.x, selimut.position.y, 0],
                        [baseCircle.position.x, baseCircle.position.y + r, 0]
                    ));
                    
                    group.add(edges);
                    
                    return group;
                }
            },
            sphere: {
                name: "Bola",
                nameEn: "Sphere",
                description: "Bola adalah bangun ruang yang dibatasi oleh satu bidang lengkung yang semua titik pada bidang tersebut berjarak sama terhadap titik pusat.",
                surfaceAreaFormula: "\\[ L = 4 \\pi r^2 \\]",
                surfaceAreaExplanation: "Luas permukaan bola adalah \\(4 \\pi r^2\\), dimana r adalah jari-jari bola.",
                volumeFormula: "\\[ V = \\frac{4}{3} \\pi r^3 \\]",
                volumeExplanation: "Volume bola adalah \\(\\frac{4}{3} \\pi r^3\\), dimana r adalah jari-jari bola.",
                dimensionLabels: ["Jari-jari (r)"],
                calculateSurfaceArea: (r) => 4 * Math.PI * r * r,
                calculateVolume: (r) => (4/3) * Math.PI * r * r * r,
                create: (r) => new THREE.SphereGeometry(r, 32, 32),
                dimensions: ["dim1"],
                needsSides: false,
                color: 0x5D5CDE,
                faceAreas: (r) => [
                    { face: "Seluruh Permukaan", area: 4 * Math.PI * r * r, position: [0, 0, 0], normal: [1, 0, 0] }
                ],
                createNet: (r) => {
                    // Create a 2D representation of sphere net
                    const group = new THREE.Group();
                    
                    // Create material
                    const material = new THREE.MeshBasicMaterial({ 
                        color: 0x5D5CDE, 
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.9
                    });
                    
                    // For a sphere, we can represent the net as a series of strips
                    // We'll create a simple pattern of 6 segments (like orange slices)
                    const numSegments = 6;
                    const segmentWidth = Math.PI * r / 2;
                    const segmentHeight = 2 * r;
                    
                    for (let i = 0; i < numSegments; i++) {
                        const segmentGeometry = new THREE.PlaneGeometry(segmentWidth, segmentHeight);
                        const segment = new THREE.Mesh(segmentGeometry, material);
                        
                        // Arrange in a horizontal row
                        segment.position.set((i - (numSegments-1)/2) * segmentWidth, 0, 0);
                        segment.originalPosition = segment.position.clone();
                        segment.targetPosition = new THREE.Vector3(0, 0, 0);
                        segment.originalRotation = new THREE.Euler(0, 0, 0);
                        segment.targetRotation = new THREE.Euler(0, i * Math.PI/3, 0);
                        
                        group.add(segment);
                    }
                    
                    // Add two "caps" for the poles
                    const capGeometry = new THREE.CircleGeometry(r, 32);
                    const northCap = new THREE.Mesh(capGeometry, new THREE.MeshBasicMaterial({
                        color: 0xFF6B6B,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.9
                    }));
                    northCap.position.set(0, segmentHeight, 0);
                    northCap.originalPosition = new THREE.Vector3(0, segmentHeight, 0);
                    northCap.targetPosition = new THREE.Vector3(0, r, 0);
                    northCap.originalRotation = new THREE.Euler(0, 0, 0);
                    northCap.targetRotation = new THREE.Euler(-Math.PI/2, 0, 0);
                    group.add(northCap);
                    
                    const southCap = new THREE.Mesh(capGeometry, new THREE.MeshBasicMaterial({
                        color: 0x4ECDC4,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.9
                    }));
                    southCap.position.set(0, -segmentHeight, 0);
                    southCap.originalPosition = new THREE.Vector3(0, -segmentHeight, 0);
                    southCap.targetPosition = new THREE.Vector3(0, -r, 0);
                    southCap.originalRotation = new THREE.Euler(0, 0, 0);
                    southCap.targetRotation = new THREE.Euler(Math.PI/2, 0, 0);
                    group.add(southCap);
                    
                    // Add label
                    const faceLabels = [
                        { text: "Bagian Utara", position: northCap.position.clone() },
                        { text: "Bagian Selatan", position: southCap.position.clone() },
                        { text: "Permukaan Bola", position: new THREE.Vector3(0, 0, 0) }
                    ];
                    
                    group.faceLabels = faceLabels;
                    
                    // Add edges
                    const edges = new THREE.Group();
                    const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
                    
                    // Add edges between segments
                    // (Simplified for brevity)
                    
                    group.add(edges);
                    
                    return group;
                }
            },
            prism: {
                name: "Prisma",
                nameEn: "Prism",
                description: "Prisma adalah bangun ruang yang memiliki alas dan atap berbentuk segi-n yang kongruen dan sisi-sisi berbentuk persegi panjang.",
                surfaceAreaFormula: "\\[ L = 2 \\times L_{\\text{alas}} + n \\times a \\times t \\]",
                surfaceAreaExplanation: "Luas permukaan prisma adalah luas kedua segi-n (\\(2 \\times L_{\\text{alas}}\\)) ditambah luas n sisi berbentuk persegi panjang (\\(n \\times a \\times t\\)), dimana n adalah jumlah sisi pada alas, a adalah panjang sisi alas segi-n, dan t adalah tinggi prisma.",
                volumeFormula: "\\[ V = L_{\\text{alas}} \\times t \\]",
                volumeExplanation: "Volume prisma adalah luas alas dikali tinggi prisma.",
                dimensionLabels: ["Panjang Sisi (a)", "Tinggi (t)"],
                calculateSurfaceArea: (a, t, sides) => {
                    const apothem = a / (2 * Math.tan(Math.PI / sides)); // apothem for regular polygon
                    const baseArea = 0.5 * sides * a * apothem;
                    return 2 * baseArea + sides * a * t;
                },
                calculateVolume: (a, t, sides) => {
                    const apothem = a / (2 * Math.tan(Math.PI / sides)); // apothem for regular polygon
                    const baseArea = 0.5 * sides * a * apothem;
                    return baseArea * t;
                },
                create: (a, t, sides) => {
                    // Create a prisma with n sides using custom geometry
                    // First create a regular polygon for the base
                    const baseShape = new THREE.Shape();
                    const radius = a / (2 * Math.sin(Math.PI / sides)); // radius of circumscribed circle
                    
                    // Add points for the regular polygon
                    for (let i = 0; i < sides; i++) {
                        const angle = (i / sides) * Math.PI * 2;
                        const x = radius * Math.cos(angle);
                        const z = radius * Math.sin(angle);
                        
                        if (i === 0) {
                            baseShape.moveTo(x, z);
                        } else {
                            baseShape.lineTo(x, z);
                        }
                    }
                    baseShape.closePath();
                    
                    // Extrude the shape to create a prism
                    const extrudeSettings = {
                        depth: t,
                        bevelEnabled: false
                    };
                    
                    const geometry = new THREE.ExtrudeGeometry(baseShape, extrudeSettings);
                    geometry.center();
                    geometry.rotateX(Math.PI / 2); // Rotate to stand upright
                    
                    return geometry;
                },
                dimensions: ["dim1", "dim3"],
                needsSides: true,
                color: 0x247BA0,
                faceAreas: (a, t, sides) => {
                    const radius = a / (2 * Math.sin(Math.PI / sides)); // radius of circumscribed circle
                    const apothem = a / (2 * Math.tan(Math.PI / sides)); // apothem
                    const baseArea = 0.5 * sides * a * apothem;
                    
                    const areas = [
                        { face: "Alas Bawah", area: baseArea, position: [0, -t/2, 0], normal: [0, -1, 0] },
                        { face: "Alas Atas", area: baseArea, position: [0, t/2, 0], normal: [0, 1, 0] }
                    ];
                    
                    // Add side faces
                    for (let i = 0; i < sides; i++) {
                        const angle = (i / sides) * Math.PI * 2;
                        const nextAngle = ((i + 1) / sides) * Math.PI * 2;
                        
                        const x1 = radius * Math.cos(angle);
                        const z1 = radius * Math.sin(angle);
                        const x2 = radius * Math.cos(nextAngle);
                        const z2 = radius * Math.sin(nextAngle);
                        
                        const centerX = (x1 + x2) / 2;
                        const centerZ = (z1 + z2) / 2;
                        
                        const nx = centerX / radius;
                        const nz = centerZ / radius;
                        
                        areas.push({
                            face: `Sisi ${i+1}`,
                            area: a * t,
                            position: [centerX, 0, centerZ],
                            normal: [nx, 0, nz]
                        });
                    }
                    
                    return areas;
                },
                createNet: (a, t, sides) => {
                    // Create a 2D net for n-sided prism
                    const group = new THREE.Group();
                    
                    // Create materials with different colors
                    const baseColors = [0xFF6B6B, 0x4ECDC4, 0xFFD166, 0xF25F5C, 0x5D5CDE, 0x247BA0];
                    const materials = [];
                    
                    // First two for top and bottom, then sides
                    materials.push(new THREE.MeshBasicMaterial({ color: baseColors[0], side: THREE.DoubleSide, transparent: true, opacity: 0.9 })); // Bottom
                    materials.push(new THREE.MeshBasicMaterial({ color: baseColors[1], side: THREE.DoubleSide, transparent: true, opacity: 0.9 })); // Top
                    
                    // Add materials for each side face
                    for (let i = 0; i < sides; i++) {
                        const colorIndex = (i % (baseColors.length - 2)) + 2; // Skip first two colors
                        materials.push(new THREE.MeshBasicMaterial({ color: baseColors[colorIndex], side: THREE.DoubleSide, transparent: true, opacity: 0.9 }));
                    }
                    
                    // Create regular polygon for base
                    const baseShape = new THREE.Shape();
                    const radius = a / (2 * Math.sin(Math.PI / sides)); // radius of circumscribed circle
                    
                    // Add points for the regular polygon
                    const basePoints = [];
                    for (let i = 0; i < sides; i++) {
                        const angle = (i / sides) * Math.PI * 2;
                        const x = radius * Math.cos(angle);
                        const z = radius * Math.sin(angle);
                        
                        basePoints.push(new THREE.Vector2(x, z));
                        
                        if (i === 0) {
                            baseShape.moveTo(x, z);
                        } else {
                            baseShape.lineTo(x, z);
                        }
                    }
                    baseShape.closePath();
                    
                    // Create bottom face
                    const baseGeometry = new THREE.ShapeGeometry(baseShape);
                    const bottomBase = new THREE.Mesh(baseGeometry, materials[0]);
                    bottomBase.position.set(0, 0, 0);
                    bottomBase.originalPosition = new THREE.Vector3(0, 0, 0);
                    bottomBase.targetPosition = new THREE.Vector3(0, -t/2, 0);
                    bottomBase.originalRotation = new THREE.Euler(0, 0, 0);
                    bottomBase.targetRotation = new THREE.Euler(Math.PI/2, 0, 0);
                    group.add(bottomBase);
                    
                    // Create top face
                    const topBase = new THREE.Mesh(baseGeometry, materials[1]);
                    topBase.position.set(0, t + 2*radius, 0);
                    topBase.originalPosition = new THREE.Vector3(0, t + 2*radius, 0);
                    topBase.targetPosition = new THREE.Vector3(0, t/2, 0);
                    topBase.originalRotation = new THREE.Euler(0, 0, 0);
                    topBase.targetRotation = new THREE.Euler(-Math.PI/2, 0, 0);
                    group.add(topBase);
                    
                    // Create side faces - arrange in a strip
                    let currentX = 0;
                    
                    for (let i = 0; i < sides; i++) {
                        const angle = (i / sides) * Math.PI * 2;
                        const nextAngle = ((i + 1) / sides) * Math.PI * 2;
                        
                        const x1 = radius * Math.cos(angle);
                        const z1 = radius * Math.sin(angle);
                        const x2 = radius * Math.cos(nextAngle);
                        const z2 = radius * Math.sin(nextAngle);
                        
                        // Calculate side length between these two points
                        const sideLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(z2 - z1, 2));
                        
                        const sideGeometry = new THREE.PlaneGeometry(sideLength, t);
                        const side = new THREE.Mesh(sideGeometry, materials[i + 2]);
                        
                        // Position sides in a row below the base
                        side.position.set(currentX + sideLength/2, -radius-t/2, 0);
                        side.originalPosition = new THREE.Vector3(currentX + sideLength/2, -radius-t/2, 0);
                        
                        // Calculate the center of this side in 3D space
                        const centerX = (x1 + x2) / 2;
                        const centerZ = (z1 + z2) / 2;
                        
                        side.targetPosition = new THREE.Vector3(centerX, 0, centerZ);
                        
                        // Calculate rotation needed to align with the base
                        const sideAngle = Math.atan2(z2 - z1, x2 - x1);
                        side.originalRotation = new THREE.Euler(0, 0, 0);
                        
                        // This rotation will connect the side to the base along the proper edge
                        side.targetRotation = new THREE.Euler(0, -sideAngle + Math.PI/2, 0);
                        
                        group.add(side);
                        
                        currentX += sideLength + 0.1; // Add some spacing
                    }
                    
                    // Add face labels
                    const faceLabels = [
                        { text: "Alas Bawah", position: bottomBase.position.clone() },
                        { text: "Alas Atas", position: topBase.position.clone() }
                    ];
                    
                    // Add labels for side faces
                    for (let i = 0; i < sides; i++) {
                        faceLabels.push({ 
                            text: `Sisi ${i+1}`, 
                            position: group.children[i+2].position.clone() 
                        });
                    }
                    
                    group.faceLabels = faceLabels;
                    
                    // Add edges
                    const edges = new THREE.Group();
                    const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
                    
                    // Helper function to create edge
                    function createEdge(p1, p2) {
                        const points = [];
                        points.push(new THREE.Vector3(p1[0], p1[1], p1[2]));
                        points.push(new THREE.Vector3(p2[0], p2[1], p2[2]));
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        return new THREE.Line(geometry, lineMaterial);
                    }
                    
                    // Add edges for base polygons
                    for (let i = 0; i < sides; i++) {
                        const pt1 = basePoints[i];
                        const pt2 = basePoints[(i + 1) % sides];
                        
                        // Bottom base edges
                        edges.add(createEdge(
                            [pt1.x, 0, pt1.y],
                            [pt2.x, 0, pt2.y]
                        ));
                        
                        // Top base edges
                        edges.add(createEdge(
                            [pt1.x, t + 2*radius, pt1.y],
                            [pt2.x, t + 2*radius, pt2.y]
                        ));
                    }
                    
                    group.add(edges);
                    
                    return group;
                }
            },
            pyramid: {
                name: "Limas",
                nameEn: "Pyramid",
                description: "Limas adalah bangun ruang yang memiliki alas berbentuk segi-n dan sisi-sisi berbentuk segitiga yang bertemu di satu titik puncak.",
                surfaceAreaFormula: "\\[ L = L_{\\text{alas}} + \\sum L_{\\text{sisi-segitiga}} \\]",
                surfaceAreaExplanation: "Luas permukaan limas adalah luas alas (\\(L_{\\text{alas}}\\)) ditambah jumlah luas seluruh sisi segitiga (\\(\\sum L_{\\text{sisi-segitiga}}\\)).",
                volumeFormula: "\\[ V = \\frac{1}{3} \\times L_{\\text{alas}} \\times t \\]",
                volumeExplanation: "Volume limas adalah sepertiga dari luas alas dikali tinggi limas, yaitu \\(\\frac{1}{3} \\times L_{\\text{alas}} \\times t\\).",
                dimensionLabels: ["Panjang Sisi (a)", "Tinggi (t)"],
                calculateSurfaceArea: (a, t, sides) => {
                    // Calculate the area of the base (regular polygon)
                    const apothem = a / (2 * Math.tan(Math.PI / sides)); // apothem for regular polygon
                    const baseArea = 0.5 * sides * a * apothem;
                    
                    // Calculate the area of each triangular face
                    const radius = a / (2 * Math.sin(Math.PI / sides)); // radius of circumscribed circle
                    const slantHeight = Math.sqrt(t*t + radius*radius); // distance from apex to edge
                    const triangleArea = 0.5 * a * slantHeight;
                    
                    return baseArea + (sides * triangleArea);
                },
                calculateVolume: (a, t, sides) => {
                    // Calculate the area of the base (regular polygon)
                    const apothem = a / (2 * Math.tan(Math.PI / sides)); // apothem for regular polygon
                    const baseArea = 0.5 * sides * a * apothem;
                    
                    return (1/3) * baseArea * t;
                },
                create: (a, t, sides) => {
                    // Create a pyramid with n sides using custom geometry
                    // First create a regular polygon for the base
                    const radius = a / (2 * Math.sin(Math.PI / sides)); // radius of circumscribed circle
                    
                    // Create a geometry for the pyramid
                    const geometry = new THREE.ConeGeometry(radius, t, sides);
                    geometry.rotateX(Math.PI); // Flip to have the base at the bottom
                    
                    return geometry;
                },
                dimensions: ["dim1", "dim3"],
                needsSides: true,
                color: 0xA066FF,
                faceAreas: (a, t, sides) => {
                    // Calculate dimensions
                    const radius = a / (2 * Math.sin(Math.PI / sides)); // radius of circumscribed circle
                    const apothem = a / (2 * Math.tan(Math.PI / sides)); // apothem for regular polygon
                    const baseArea = 0.5 * sides * a * apothem;
                    const slantHeight = Math.sqrt(t*t + radius*radius); // distance from apex to edge
                    
                    const areas = [
                        { face: "Alas", area: baseArea, position: [0, -t/2, 0], normal: [0, -1, 0] }
                    ];
                    
                    // Add triangular faces
                    for (let i = 0; i < sides; i++) {
                        const angle = (i / sides) * Math.PI * 2;
                        const nextAngle = ((i + 1) / sides) * Math.PI * 2;
                        
                        const x1 = radius * Math.cos(angle);
                        const z1 = radius * Math.sin(angle);
                        const x2 = radius * Math.cos(nextAngle);
                        const z2 = radius * Math.sin(nextAngle);
                        
                        const centerX = (x1 + x2) / 2;
                        const centerZ = (z1 + z2) / 2;
                        const centerY = -t/4; // Position halfway from base to apex
                        
                        const triangleArea = 0.5 * a * slantHeight;
                        
                        // Create a normal that points outward from the triangle face
                        const dx = centerX;
                        const dy = t/2 + centerY; // From the center of the face to the apex
                        const dz = centerZ;
                        const length = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        
                        areas.push({
                            face: `Sisi ${i+1}`,
                            area: triangleArea,
                            position: [centerX, centerY, centerZ],
                            normal: [dx/length, dy/length, dz/length]
                        });
                    }
                    
                    return areas;
                },
                createNet: (a, t, sides) => {
                    // Create a 2D net for pyramid
                    const group = new THREE.Group();
                    
                    // Create materials with different colors
                    const baseColors = [0xFF6B6B, 0x4ECDC4, 0xFFD166, 0xF25F5C, 0x5D5CDE, 0x247BA0, 0xA066FF];
                    const materials = [];
                    
                    // First for base, then triangular faces
                    materials.push(new THREE.MeshBasicMaterial({ color: baseColors[0], side: THREE.DoubleSide, transparent: true, opacity: 0.9 })); // Base
                    
                    // Add materials for each triangular face
                    for (let i = 0; i < sides; i++) {
                        const colorIndex = (i % (baseColors.length - 1)) + 1; // Skip first color
                        materials.push(new THREE.MeshBasicMaterial({ color: baseColors[colorIndex], side: THREE.DoubleSide, transparent: true, opacity: 0.9 }));
                    }
                    
                    // Create regular polygon for base
                    const baseShape = new THREE.Shape();
                    const radius = a / (2 * Math.sin(Math.PI / sides)); // radius of circumscribed circle
                    
                    // Add points for the regular polygon
                    const basePoints = [];
                    for (let i = 0; i < sides; i++) {
                        const angle = (i / sides) * Math.PI * 2;
                        const x = radius * Math.cos(angle);
                        const z = radius * Math.sin(angle);
                        
                        basePoints.push(new THREE.Vector2(x, z));
                        
                        if (i === 0) {
                            baseShape.moveTo(x, z);
                        } else {
                            baseShape.lineTo(x, z);
                        }
                    }
                    baseShape.closePath();
                    
                    // Create base
                    const baseGeometry = new THREE.ShapeGeometry(baseShape);
                    const base = new THREE.Mesh(baseGeometry, materials[0]);
                    base.position.set(0, 0, 0);
                    base.originalPosition = new THREE.Vector3(0, 0, 0);
                    base.targetPosition = new THREE.Vector3(0, -t/2, 0);
                    base.originalRotation = new THREE.Euler(0, 0, 0);
                    base.targetRotation = new THREE.Euler(Math.PI/2, 0, 0);
                    group.add(base);
                    
                    // Calculate slant height for triangular faces
                    const slantHeight = Math.sqrt(t*t + radius*radius);
                    
                    // Create triangular faces and arrange them in a fan around the base
                    for (let i = 0; i < sides; i++) {
                        const angle = (i / sides) * Math.PI * 2;
                        const nextAngle = ((i + 1) / sides) * Math.PI * 2;
                        
                        const x1 = radius * Math.cos(angle);
                        const z1 = radius * Math.sin(angle);
                        const x2 = radius * Math.cos(nextAngle);
                        const z2 = radius * Math.sin(nextAngle);
                        
                        // Calculate the side length (distance between vertices)
                        const sideLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(z2 - z1, 2));
                        
                        // Create a triangle geometry
                        const triangleShape = new THREE.Shape();
                        triangleShape.moveTo(0, 0);
                        triangleShape.lineTo(sideLength, 0);
                        triangleShape.lineTo(sideLength/2, slantHeight);
                        triangleShape.closePath();
                        
                        const triangleGeometry = new THREE.ShapeGeometry(triangleShape);
                        const triangle = new THREE.Mesh(triangleGeometry, materials[i+1]);
                        
                        // Position triangles around the base
                        const baseAngle = Math.atan2(z1, x1);
                        const rotationAngle = baseAngle + Math.PI/2;
                        
                        // Calculate position at the edge of the base
                        triangle.position.set(
                            radius * Math.cos(baseAngle),
                            -radius * Math.sin(baseAngle),
                            0
                        );
                        
                        // Rotate the triangle to align with the base edge
                        triangle.rotation.z = rotationAngle;
                        
                        // Store original position and rotation for animation
                        triangle.originalPosition = triangle.position.clone();
                        triangle.originalRotation = triangle.rotation.clone();
                        
                        // Calculate the target position and rotation for 3D form
                        // The target position is the midpoint of the base edge
                        const midX = (x1 + x2) / 2;
                        const midZ = (z1 + z2) / 2;
                        
                        // Calculate the angles needed to position the face correctly in 3D
                        const edgeAngle = Math.atan2(z2 - z1, x2 - x1);
                        
                        triangle.targetPosition = new THREE.Vector3(
                            midX / 2, // Adjust as needed
                            -t/4,    // Halfway up
                            midZ / 2  // Adjust as needed
                        );
                        
                        // Set the target rotation to fold the triangle up to form the pyramid
                        // This is a complex rotation that requires trigonometric calculations
                        triangle.targetRotation = new THREE.Euler(
                            Math.PI/4,          // Tilt upward
                            edgeAngle + Math.PI/2, // Rotate to face outward
                            0
                        );
                        
                        group.add(triangle);
                    }
                    
                    // Add face labels
                    const faceLabels = [
                        { text: "Alas", position: base.position.clone() }
                    ];
                    
                    // Add labels for triangular faces
                    for (let i = 0; i < sides; i++) {
                        faceLabels.push({ 
                            text: `Sisi ${i+1}`, 
                            position: group.children[i+1].position.clone().add(new THREE.Vector3(0, slantHeight/2, 0))
                        });
                    }
                    
                    group.faceLabels = faceLabels;
                    
                    // Add edges
                    const edges = new THREE.Group();
                    const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
                    
                    // Helper function to create edge
                    function createEdge(p1, p2) {
                        const points = [];
                        points.push(new THREE.Vector3(p1[0], p1[1], p1[2]));
                        points.push(new THREE.Vector3(p2[0], p2[1], p2[2]));
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        return new THREE.Line(geometry, lineMaterial);
                    }
                    
                    // Add edges for base
                    for (let i = 0; i < sides; i++) {
                        const pt1 = basePoints[i];
                        const pt2 = basePoints[(i + 1) % sides];
                        
                        edges.add(createEdge(
                            [pt1.x, 0, pt1.y],
                            [pt2.x, 0, pt2.y]
                        ));
                    }
                    
                    group.add(edges);
                    
                    return group;
                }
            }
        };
        
        // DOM Elements
        const shapeBtns = document.querySelectorAll('.shape-btn');
        const dimension1Slider = document.getElementById('dimension-1');
        const dimension2Slider = document.getElementById('dimension-2');
        const dimension3Slider = document.getElementById('dimension-3');
        const sidesSlider = document.getElementById('sides-slider');
        const dimension1Value = document.getElementById('dimension-1-value');
        const dimension2Value = document.getElementById('dimension-2-value');
        const dimension3Value = document.getElementById('dimension-3-value');
        const sidesValue = document.getElementById('sides-value');
        const dimension1Label = document.getElementById('dimension-1-label');
        const dimension2Label = document.getElementById('dimension-2-label');
        const dimension3Label = document.getElementById('dimension-3-label');
        const sidesLabel = document.getElementById('sides-label');
        const dimension1Container = document.getElementById('dimension-slider-1-container');
        const dimension2Container = document.getElementById('dimension-slider-2-container');
        const dimension3Container = document.getElementById('dimension-slider-3-container');
        const sidesContainer = document.getElementById('sides-slider-container');
        const loadingElement = document.getElementById('loading');
        const toggleAxes = document.getElementById('toggle-axes');
        const toggleSurface = document.getElementById('toggle-surface');
        const toggleNet = document.getElementById('toggle-net');
        const surfaceInfo = document.getElementById('surface-info');
        const netInfo = document.getElementById('net-info');
        const foldAnimationBtn = document.getElementById('fold-animation-btn');
        const canvasContainer = document.getElementById('canvas-container');
        
        // Initialize Scene
        function initScene() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x4158D0);
            
            // Create camera
            const container = document.getElementById('scene');
            const aspect = container.clientWidth / container.clientHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
            camera.position.z = 5;
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            // Add orbit controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            // Add directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7);
            scene.add(directionalLight);
            
            // Add another directional light for better illumination
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
            directionalLight2.position.set(-5, -10, -7);
            scene.add(directionalLight2);
            
            // Add coordinate axes
            addCoordinateAxes();
            
            // Handle window resize
            window.addEventListener('resize', () => {
                const container = document.getElementById('scene');
                const aspect = container.clientWidth / container.clientHeight;
                camera.aspect = aspect;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
            
            // Initialize with cube
            createShape('cube');
            
            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                
                // Add slight rotation for visual interest when not being controlled
                if (!controls.enableRotate) {
                    currentShape.rotation.y += 0.01;
                }
                
                controls.update();
                
                // Update face labels if net visualization is active
                if (netVisualizationMode && netVisualization) {
                    updateNetLabels();
                }
                
                renderer.render(scene, camera);
            }
            
            animate();
            
            // Hide loading indicator
            loadingElement.style.display = 'none';
        }
        
        // Add coordinate axes
        function addCoordinateAxes() {
            if (axesHelper) {
                scene.remove(axesHelper);
            }
            
            axesHelper = new THREE.Group();
            
            // Create axes with a length of 5 units
            const axesLength = 5;
            
            // X-axis (red)
            const xAxisGeometry = new THREE.BufferGeometry();
            xAxisGeometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, axesLength, 0, 0], 3));
            const xAxisMaterial = new THREE.LineBasicMaterial({ color: 0xff5555, linewidth: 3 });
            const xAxis = new THREE.Line(xAxisGeometry, xAxisMaterial);
            
            // Y-axis (green)
            const yAxisGeometry = new THREE.BufferGeometry();
            yAxisGeometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, axesLength, 0], 3));
            const yAxisMaterial = new THREE.LineBasicMaterial({ color: 0x55ff55, linewidth: 3 });
            const yAxis = new THREE.Line(yAxisGeometry, yAxisMaterial);
            
            // Z-axis (blue)
            const zAxisGeometry = new THREE.BufferGeometry();
            zAxisGeometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, axesLength], 3));
            const zAxisMaterial = new THREE.LineBasicMaterial({ color: 0x5555ff, linewidth: 3 });
            const zAxis = new THREE.Line(zAxisGeometry, zAxisMaterial);
            
            // Add arrows to the ends of the axes
            const arrowSize = 0.15;
            
            // X-axis arrow
            const xArrowCone = new THREE.ConeGeometry(arrowSize, arrowSize * 2, 8);
            const xArrowMaterial = new THREE.MeshBasicMaterial({ color: 0xff5555 });
            const xArrow = new THREE.Mesh(xArrowCone, xArrowMaterial);
            xArrow.position.set(axesLength, 0, 0);
            xArrow.rotation.z = -Math.PI / 2;
            
            // Y-axis arrow
            const yArrowCone = new THREE.ConeGeometry(arrowSize, arrowSize * 2, 8);
            const yArrowMaterial = new THREE.MeshBasicMaterial({ color: 0x55ff55 });
            const yArrow = new THREE.Mesh(yArrowCone, yArrowMaterial);
            yArrow.position.set(0, axesLength, 0);
            
            // Z-axis arrow
            const zArrowCone = new THREE.ConeGeometry(arrowSize, arrowSize * 2, 8);
            const zArrowMaterial = new THREE.MeshBasicMaterial({ color: 0x5555ff });
            const zArrow = new THREE.Mesh(zArrowCone, zArrowMaterial);
            zArrow.position.set(0, 0, axesLength);
            zArrow.rotation.x = Math.PI / 2;
            
            // Add ticks for units
            for (let i = 1; i < axesLength; i++) {
                // X-axis ticks
                const xTickGeometry = new THREE.BufferGeometry();
                xTickGeometry.setAttribute('position', new THREE.Float32BufferAttribute([
                    i, -0.05, 0, i, 0.05, 0
                ], 3));
                const xTick = new THREE.Line(xTickGeometry, xAxisMaterial);
                
                // Y-axis ticks
                const yTickGeometry = new THREE.BufferGeometry();
                yTickGeometry.setAttribute('position', new THREE.Float32BufferAttribute([
                    -0.05, i, 0, 0.05, i, 0
                ], 3));
                const yTick = new THREE.Line(yTickGeometry, yAxisMaterial);
                
                // Z-axis ticks
                const zTickGeometry = new THREE.BufferGeometry();
                zTickGeometry.setAttribute('position', new THREE.Float32BufferAttribute([
                    -0.05, 0, i, 0.05, 0, i
                ], 3));
                const zTick = new THREE.Line(zTickGeometry, zAxisMaterial);
                
                axesHelper.add(xTick);
                axesHelper.add(yTick);
                axesHelper.add(zTick);
            }
            
            // Add axis labels (simple text)
            const xLabelDiv = document.createElement('div');
            xLabelDiv.className = 'axis-label axis-x';
            xLabelDiv.textContent = 'X';
            xLabelDiv.style.position = 'absolute';
            document.getElementById('scene').appendChild(xLabelDiv);
            
            const yLabelDiv = document.createElement('div');
            yLabelDiv.className = 'axis-label axis-y';
            yLabelDiv.textContent = 'Y';
            yLabelDiv.style.position = 'absolute';
            document.getElementById('scene').appendChild(yLabelDiv);
            
            const zLabelDiv = document.createElement('div');
            zLabelDiv.className = 'axis-label axis-z';
            zLabelDiv.textContent = 'Z';
            zLabelDiv.style.position = 'absolute';
            document.getElementById('scene').appendChild(zLabelDiv);
            
            // Position the labels correctly in 3D space
            function updateAxisLabels() {
                // Project 3D positions to 2D screen coordinates
                const canvas = renderer.domElement;
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;
                
                // X-axis label
                const xVector = new THREE.Vector3(axesLength + 0.3, 0, 0);
                const xScreenPos = xVector.project(camera);
                xLabelDiv.style.left = (width * (xScreenPos.x * 0.5 + 0.5)) + 'px';
                xLabelDiv.style.top = (height * (-xScreenPos.y * 0.5 + 0.5)) + 'px';
                
                // Y-axis label
                const yVector = new THREE.Vector3(0, axesLength + 0.3, 0);
                const yScreenPos = yVector.project(camera);
                yLabelDiv.style.left = (width * (yScreenPos.x * 0.5 + 0.5)) + 'px';
                yLabelDiv.style.top = (height * (-yScreenPos.y * 0.5 + 0.5)) + 'px';
                
                // Z-axis label
                const zVector = new THREE.Vector3(0, 0, axesLength + 0.3);
                const zScreenPos = zVector.project(camera);
                zLabelDiv.style.left = (width * (zScreenPos.x * 0.5 + 0.5)) + 'px';
                zLabelDiv.style.top = (height * (-zScreenPos.y * 0.5 + 0.5)) + 'px';
            }
            
            // Update axis labels on render
            controls.addEventListener('change', updateAxisLabels);
            window.addEventListener('resize', updateAxisLabels);
            
            // Call once to position correctly initially
            setTimeout(updateAxisLabels, 100);
            
            axesHelper.add(xAxis);
            axesHelper.add(yAxis);
            axesHelper.add(zAxis);
            axesHelper.add(xArrow);
            axesHelper.add(yArrow);
            axesHelper.add(zArrow);
            
            scene.add(axesHelper);
        }
        
        // Create shape based on type
        function createShape(shapeType) {
            // Clear existing shape
            if (currentShape) {
                scene.remove(currentShape);
            }
            
            // Clear any surface area visualization
            if (surfaceAreaVisualization) {
                scene.remove(surfaceAreaVisualization);
                surfaceAreaVisualization = null;
                
                // Remove face area indicators if any
                const existingLabels = document.querySelectorAll('.face-area');
                existingLabels.forEach(label => label.remove());
            }
            
            // Clear any net visualization
            if (netVisualization) {
                scene.remove(netVisualization);
                netVisualization = null;
                
                // Remove face labels if any
                const existingNetLabels = document.querySelectorAll('.face-label');
                existingNetLabels.forEach(label => label.remove());
            }
            
            const shape = shapeData[shapeType];
            const requiredDims = shape.dimensions;
            
            // Get dimensions
            let geometry;
            if (shapeType === 'cube') {
                geometry = shape.create(dimensions.dim1);
            } else if (shapeType === 'cuboid') {
                geometry = shape.create(dimensions.dim1, dimensions.dim2, dimensions.dim3);
            } else if (shapeType === 'cylinder' || shapeType === 'cone') {
                geometry = shape.create(dimensions.dim1, dimensions.dim3);
            } else if (shapeType === 'sphere') {
                geometry = shape.create(dimensions.dim1);
            } else if (shapeType === 'prism' || shapeType === 'pyramid') {
                geometry = shape.create(dimensions.dim1, dimensions.dim3, dimensions.sides);
            }
            
            // Create material with phong for better lighting
            const material = new THREE.MeshPhongMaterial({
                color: shape.color,
                transparent: true,
                opacity: 0.9,
                specular: 0x111111,
                shininess: 30,
                side: THREE.DoubleSide
            });
            
            // Create edge wireframe for better visibility
            const edges = new THREE.EdgesGeometry(geometry);
            const lineMaterial = new THREE.LineBasicMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0.5
            });
            const wireframe = new THREE.LineSegments(edges, lineMaterial);
            
            // Create mesh
            currentShape = new THREE.Group();
            const mesh = new THREE.Mesh(geometry, material);
            currentShape.add(mesh);
            currentShape.add(wireframe);
            scene.add(currentShape);
            
            // Show surface area visualization if enabled
            if (surfaceVisualizationMode) {
                createSurfaceAreaVisualization(shapeType);
            }
            
            // Show net visualization if enabled
            if (netVisualizationMode) {
                createNetVisualization(shapeType);
            }
            
            // Update UI
            updateShapeInfo(shapeType);
            updateDimensionSliders(shapeType);
            updateCalculations(shapeType);
            
            // Return the created shape
            return currentShape;
        }
        
        // Create surface area visualization for a shape
        function createSurfaceAreaVisualization(shapeType) {
            if (surfaceAreaVisualization) {
                scene.remove(surfaceAreaVisualization);
                
                // Remove existing face labels
                const existingLabels = document.querySelectorAll('.face-area');
                existingLabels.forEach(label => label.remove());
            }
            
            surfaceAreaVisualization = new THREE.Group();
            
            const shape = shapeData[shapeType];
            let faceAreas;
            
            // Get face areas based on shape type
            if (shapeType === 'cube') {
                faceAreas = shape.faceAreas(dimensions.dim1);
            } else if (shapeType === 'cuboid') {
                faceAreas = shape.faceAreas(dimensions.dim1, dimensions.dim2, dimensions.dim3);
            } else if (shapeType === 'cylinder' || shapeType === 'cone') {
                faceAreas = shape.faceAreas(dimensions.dim1, dimensions.dim3);
            } else if (shapeType === 'sphere') {
                faceAreas = shape.faceAreas(dimensions.dim1);
            } else if (shapeType === 'prism' || shapeType === 'pyramid') {
                faceAreas = shape.faceAreas(dimensions.dim1, dimensions.dim3, dimensions.sides);
            }
            
            // Show surface info
            surfaceInfo.style.display = 'block';
            surfaceInfo.innerHTML = '<strong>Visualisasi Luas Permukaan</strong><br>Perhatikan penanda pada setiap permukaan bangun ruang.';
            
            // Create face labels
            faceAreas.forEach((face, index) => {
                // Create face indicator
                const indicatorGeometry = new THREE.SphereGeometry(0.05, 16, 16);
                const indicatorMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffcc00,
                    transparent: true,
                    opacity: 0.8
                });
                const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
                
                // Position indicator on the face
                indicator.position.set(face.position[0], face.position[1], face.position[2]);
                
                // Add indicator to visualization group
                surfaceAreaVisualization.add(indicator);
                
                // Create a div for the face area label
                const labelDiv = document.createElement('div');
                labelDiv.className = 'face-area';
                labelDiv.textContent = `${face.face}: ${Math.round(face.area * 100) / 100} unit²`;
                labelDiv.id = `face-area-${index}`;
                labelDiv.style.display = 'block';
                document.getElementById('scene').appendChild(labelDiv);
                
                // Update label position on render
                function updateLabel() {
                    const worldPos = indicator.position.clone();
                    const canvas = renderer.domElement;
                    const vector = worldPos.project(camera);
                    
                    const x = (vector.x * 0.5 + 0.5) * canvas.clientWidth;
                    const y = (-vector.y * 0.5 + 0.5) * canvas.clientHeight;
                    
                    labelDiv.style.left = x + 'px';
                    labelDiv.style.top = y + 'px';
                    
                    // Check if the label is visible (in front of the camera)
                    const isBehindCamera = worldPos.clone().sub(camera.position).normalize().dot(camera.getWorldDirection(new THREE.Vector3())) < 0;
                    
                    // Only show labels that are in front of the camera
                    labelDiv.style.display = isBehindCamera ? 'none' : 'block';
                }
                
                // Update label positions when the camera or controls change
                controls.addEventListener('change', updateLabel);
                window.addEventListener('resize', updateLabel);
                
                // Call once to position correctly initially
                setTimeout(updateLabel, 100);
            });
            
            scene.add(surfaceAreaVisualization);
        }
        
        // Create net visualization for a shape
        function createNetVisualization(shapeType) {
            if (netVisualization) {
                scene.remove(netVisualization);
                
                // Remove existing face labels
                const existingLabels = document.querySelectorAll('.face-label');
                existingLabels.forEach(label => label.remove());
            }
            
            const shape = shapeData[shapeType];
            
            // Hide the 3D shape when showing net
            if (currentShape) {
                currentShape.visible = false;
            }
            
            // Hide surface visualization when showing net
            if (surfaceAreaVisualization) {
                surfaceAreaVisualization.visible = false;
            }
            
            // Create net based on shape type
            if (shapeType === 'cube') {
                netVisualization = shape.createNet(dimensions.dim1);
            } else if (shapeType === 'cuboid') {
                netVisualization = shape.createNet(dimensions.dim1, dimensions.dim2, dimensions.dim3);
            } else if (shapeType === 'cylinder' || shapeType === 'cone') {
                netVisualization = shape.createNet(dimensions.dim1, dimensions.dim3);
            } else if (shapeType === 'sphere') {
                netVisualization = shape.createNet(dimensions.dim1);
            } else if (shapeType === 'prism' || shapeType === 'pyramid') {
                netVisualization = shape.createNet(dimensions.dim1, dimensions.dim3, dimensions.sides);
            }
            
            scene.add(netVisualization);
            
            // Position camera to better view the flat net
            camera.position.set(0, 7, 0);
            camera.lookAt(0, 0, 0);
            controls.update();
            
            // Create face labels
            if (netVisualization.faceLabels) {
                netVisualization.faceLabels.forEach((faceInfo, index) => {
                    const labelDiv = document.createElement('div');
                    labelDiv.className = 'face-label';
                    labelDiv.textContent = faceInfo.text;
                    labelDiv.id = `face-label-${index}`;
                    document.getElementById('scene').appendChild(labelDiv);
                });
            }
            
            // Show net info
            netInfo.style.display = 'block';
            netInfo.innerHTML = '<strong>Jaring-jaring ' + shape.name + '</strong><br>' +
                                'Visualisasi bagaimana permukaan bangun ruang jika dibuka menjadi 2D. Klik tombol lipat untuk melihat animasi pembentukan bangun ruang.';
            
            // Show fold animation button
            foldAnimationBtn.style.display = 'block';
            foldAnimationBtn.textContent = 'Lipat ke Bentuk 3D';
            
            // Update net face labels
            updateNetLabels();
            
            // Reset folded state
            folded = false;
        }
        
        // Update net face labels
        function updateNetLabels() {
            if (!netVisualization || !netVisualization.faceLabels) return;
            
            const canvas = renderer.domElement;
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            
            netVisualization.faceLabels.forEach((faceInfo, index) => {
                const labelDiv = document.getElementById(`face-label-${index}`);
                if (!labelDiv) return;
                
                // Get world position from the face position
                const worldPos = faceInfo.position.clone();
                
                // Project to screen coordinates
                const vector = worldPos.project(camera);
                
                const x = (vector.x * 0.5 + 0.5) * width;
                const y = (-vector.y * 0.5 + 0.5) * height;
                
                // Update label position
                labelDiv.style.left = x + 'px';
                labelDiv.style.top = y + 'px';
                
                // Hide labels behind the camera
                const isBehindCamera = worldPos.clone().sub(camera.position).normalize().dot(camera.getWorldDirection(new THREE.Vector3())) < 0;
                labelDiv.style.display = isBehindCamera ? 'none' : 'block';
            });
        }
        
        // Animate folding/unfolding of net
        function animateFoldUnfold() {
            if (animationInProgress || !netVisualization) return;
            
            animationInProgress = true;
            
            // Get children that have animation properties
            const animatableChildren = [];
            netVisualization.children.forEach(child => {
                if (child.originalPosition && child.targetPosition) {
                    animatableChildren.push(child);
                }
            });
            
            // No animatable children, exit
            if (animatableChildren.length === 0) {
                animationInProgress = false;
                return;
            }
            
            // Duration of animation in milliseconds
            const duration = 2000;
            const startTime = Date.now();
            
            // Update camera to follow the folding process
            if (!folded) {
                // When folding from 2D to 3D, gradually move camera from top view to perspective view
                const startCameraPos = new THREE.Vector3(0, 7, 0);
                const endCameraPos = new THREE.Vector3(5, 5, 5);
                
                // Update camera position during animation
                function updateCamera(progress) {
                    camera.position.lerpVectors(startCameraPos, endCameraPos, progress);
                    camera.lookAt(0, 0, 0);
                    controls.update();
                }
            }
            
            function animate() {
                const elapsedTime = Date.now() - startTime;
                const progress = Math.min(elapsedTime / duration, 1);
                
                // Easing function for smooth animation
                const easedProgress = folded ? 
                    1 - Math.pow(1 - progress, 2) : // Ease out for unfolding
                    Math.pow(progress, 2);          // Ease in for folding
                
                // Update positions and rotations of all faces
                animatableChildren.forEach(child => {
                    if (folded) {
                        // Unfolding (from 3D to 2D)
                        child.position.lerpVectors(child.targetPosition, child.originalPosition, easedProgress);
                        
                        // Interpolate rotation using quaternions for smooth rotation
                        const targetQuat = new THREE.Quaternion().setFromEuler(child.targetRotation);
                        const origQuat = new THREE.Quaternion().setFromEuler(child.originalRotation);
                        child.quaternion.slerpQuaternions(targetQuat, origQuat, easedProgress);
                    } else {
                        // Folding (from 2D to 3D)
                        child.position.lerpVectors(child.originalPosition, child.targetPosition, easedProgress);
                        
                        // Interpolate rotation using quaternions for smooth rotation
                        const origQuat = new THREE.Quaternion().setFromEuler(child.originalRotation);
                        const targetQuat = new THREE.Quaternion().setFromEuler(child.targetRotation);
                        child.quaternion.slerpQuaternions(origQuat, targetQuat, easedProgress);
                    }
                });
                
                // Update camera during folding animation
                if (!folded) {
                    updateCamera(easedProgress);
                }
                
                // Continue animation if not complete
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Animation complete
                    animationInProgress = false;
                    folded = !folded;
                    
                    // Enable controls during and after animation
                    controls.enabled = true;
                    
                    // If now folded, switch to 3D shape
                    if (folded) {
                        // Show 3D shape
                        if (currentShape) {
                            currentShape.visible = true;
                        }
                        
                        // Hide net visualization
                        if (netVisualization) {
                            netVisualization.visible = false;
                        }
                        
                        // Hide face labels
                        const faceLabels = document.querySelectorAll('.face-label');
                        faceLabels.forEach(label => {
                            label.style.display = 'none';
                        });
                        
                        // Show surface area visualization if it was active
                        if (surfaceVisualizationMode && surfaceAreaVisualization) {
                            surfaceAreaVisualization.visible = true;
                        }
                    } else {
                        // Position camera to better view the flat net when unfolding is complete
                        camera.position.set(0, 7, 0);
                        camera.lookAt(0, 0, 0);
                        controls.update();
                        
                        // Show net, hide 3D shape
                        if (currentShape) {
                            currentShape.visible = false;
                        }
                        
                        if (netVisualization) {
                            netVisualization.visible = true;
                        }
                        
                        // Hide surface area visualization
                        if (surfaceAreaVisualization) {
                            surfaceAreaVisualization.visible = false;
                        }
                    }
                    
                    // Update button text
                    foldAnimationBtn.textContent = folded ? 'Buka Jaring-jaring' : 'Lipat ke Bentuk 3D';
                }
            }
            
            // Start animation but don't disable controls
            animate();
        }
        
        // Update shape information in the UI
        function updateShapeInfo(shapeType) {
            const shape = shapeData[shapeType];
            
            document.getElementById('shape-name').textContent = shape.name;
            document.getElementById('shape-description').textContent = shape.description;
            document.getElementById('surface-area-formula').innerHTML = shape.surfaceAreaFormula;
            document.getElementById('surface-area-explanation').innerHTML = shape.surfaceAreaExplanation;
            document.getElementById('volume-formula').innerHTML = shape.volumeFormula;
            document.getElementById('volume-explanation').innerHTML = shape.volumeExplanation;
            
            // Update MathJax
            if (window.MathJax && window.MathJax.typeset) {
                window.MathJax.typeset();
            } else if (window.MathJax && window.MathJax.Hub) {
                window.MathJax.Hub.Queue(["Typeset", window.MathJax.Hub]);
            } else if (window.MathJax && window.MathJax.typesetPromise) {
                window.MathJax.typesetPromise();
            }
        }
        
        // Update dimension sliders based on shape
        function updateDimensionSliders(shapeType) {
            const shape = shapeData[shapeType];
            const requiredDims = shape.dimensions;
            const dimLabels = shape.dimensionLabels;
            
            // Show/hide sliders as needed
            dimension1Container.style.display = requiredDims.includes('dim1') ? 'block' : 'none';
            dimension2Container.style.display = requiredDims.includes('dim2') ? 'block' : 'none';
            dimension3Container.style.display = requiredDims.includes('dim3') ? 'block' : 'none';
            sidesContainer.style.display = shape.needsSides ? 'block' : 'none';
            
            // Update labels
            if (requiredDims.includes('dim1')) {
                dimension1Label.innerHTML = `${dimLabels[0]}: <span id="dimension-1-value">${dimensions.dim1}</span>`;
                dimension1Value.textContent = dimensions.dim1;
            }
            
            if (requiredDims.includes('dim2')) {
                dimension2Label.innerHTML = `${dimLabels[1]}: <span id="dimension-2-value">${dimensions.dim2}</span>`;
                dimension2Value.textContent = dimensions.dim2;
            }
            
            if (requiredDims.includes('dim3')) {
                // For shapes with 2 dimensions, the second dimension is at index 1, but for dim3
                const labelIndex = dimLabels.length > 2 ? 2 : 1;
                dimension3Label.innerHTML = `${dimLabels[labelIndex]}: <span id="dimension-3-value">${dimensions.dim3}</span>`;
                dimension3Value.textContent = dimensions.dim3;
            }
            
            if (shape.needsSides) {
                // Update sides slider
                sidesLabel.innerHTML = `Jumlah Sisi: <span id="sides-value">${dimensions.sides}</span>`;
                sidesValue.textContent = dimensions.sides;
                
                // For pyramid, adjust the label to be more specific
                if (shapeType === 'pyramid') {
                    sidesLabel.innerHTML = `Jumlah Sisi Alas: <span id="sides-value">${dimensions.sides}</span>`;
                }
            }
        }
        
        // Update calculations based on current dimensions
        function updateCalculations(shapeType) {
            const shape = shapeData[shapeType];
            let surfaceArea, volume, dimensionsText;
            
            if (shapeType === 'cube') {
                surfaceArea = shape.calculateSurfaceArea(dimensions.dim1);
                volume = shape.calculateVolume(dimensions.dim1);
                dimensionsText = `Sisi (s) = ${dimensions.dim1} unit`;
            } else if (shapeType === 'cuboid') {
                surfaceArea = shape.calculateSurfaceArea(dimensions.dim1, dimensions.dim2, dimensions.dim3);
                volume = shape.calculateVolume(dimensions.dim1, dimensions.dim2, dimensions.dim3);
                dimensionsText = `Panjang (p) = ${dimensions.dim1} unit, Lebar (l) = ${dimensions.dim2} unit, Tinggi (t) = ${dimensions.dim3} unit`;
            } else if (shapeType === 'cylinder' || shapeType === 'cone') {
                surfaceArea = shape.calculateSurfaceArea(dimensions.dim1, dimensions.dim3);
                volume = shape.calculateVolume(dimensions.dim1, dimensions.dim3);
                dimensionsText = `Jari-jari (r) = ${dimensions.dim1} unit, Tinggi (t) = ${dimensions.dim3} unit`;
            } else if (shapeType === 'sphere') {
                surfaceArea = shape.calculateSurfaceArea(dimensions.dim1);
                volume = shape.calculateVolume(dimensions.dim1);
                dimensionsText = `Jari-jari (r) = ${dimensions.dim1} unit`;
            } else if (shapeType === 'prism') {
                surfaceArea = shape.calculateSurfaceArea(dimensions.dim1, dimensions.dim3, dimensions.sides);
                volume = shape.calculateVolume(dimensions.dim1, dimensions.dim3, dimensions.sides);
                dimensionsText = `Sisi Alas (a) = ${dimensions.dim1} unit, Tinggi (t) = ${dimensions.dim3} unit, Jumlah Sisi Alas = ${dimensions.sides}`;
            } else if (shapeType === 'pyramid') {
                surfaceArea = shape.calculateSurfaceArea(dimensions.dim1, dimensions.dim3, dimensions.sides);
                volume = shape.calculateVolume(dimensions.dim1, dimensions.dim3, dimensions.sides);
                dimensionsText = `Sisi Alas (a) = ${dimensions.dim1} unit, Tinggi (t) = ${dimensions.dim3} unit, Jumlah Sisi Alas = ${dimensions.sides}`;
            }
            
            // Round to 2 decimal places
            surfaceArea = Math.round(surfaceArea * 100) / 100;
            volume = Math.round(volume * 100) / 100;
            
            // Update UI
            document.getElementById('current-dimensions').textContent = dimensionsText;
            document.getElementById('current-surface-area').textContent = `Luas Permukaan = ${surfaceArea} unit²`;
            document.getElementById('current-volume').textContent = `Volume = ${volume} unit³`;
            
            // Update surface area visualization if enabled
            if (surfaceVisualizationMode) {
                createSurfaceAreaVisualization(shapeType);
            }
            
            // Update net visualization if enabled
            if (netVisualizationMode) {
                createNetVisualization(shapeType);
            }
        }
        
        // Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            initScene();
            
            // Shape selection buttons
            shapeBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    // Update active class
                    shapeBtns.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    
                    // Create selected shape
                    const shapeType = this.getAttribute('data-shape');
                    createShape(shapeType);
                });
            });
            
            // Dimension sliders
            dimension1Slider.addEventListener('input', function() {
                dimensions.dim1 = parseFloat(this.value);
                dimension1Value.textContent = dimensions.dim1;
                const activeShape = document.querySelector('.shape-btn.active').getAttribute('data-shape');
                createShape(activeShape);
            });
            
            dimension2Slider.addEventListener('input', function() {
                dimensions.dim2 = parseFloat(this.value);
                dimension2Value.textContent = dimensions.dim2;
                const activeShape = document.querySelector('.shape-btn.active').getAttribute('data-shape');
                createShape(activeShape);
            });
            
            dimension3Slider.addEventListener('input', function() {
                dimensions.dim3 = parseFloat(this.value);
                dimension3Value.textContent = dimensions.dim3;
                const activeShape = document.querySelector('.shape-btn.active').getAttribute('data-shape');
                createShape(activeShape);
            });
            
            sidesSlider.addEventListener('input', function() {
                dimensions.sides = parseInt(this.value);
                sidesValue.textContent = dimensions.sides;
                const activeShape = document.querySelector('.shape-btn.active').getAttribute('data-shape');
                createShape(activeShape);
            });
            
            // Toggle coordinate axes
            toggleAxes.addEventListener('change', function() {
                axesMode = this.checked;
                
                if (axesMode) {
                    // Show coordinate axes
                    addCoordinateAxes();
                } else {
                    // Hide coordinate axes
                    if (axesHelper) {
                        scene.remove(axesHelper);
                        
                        // Remove axis labels
                        const axisLabels = document.querySelectorAll('.axis-label');
                        axisLabels.forEach(label => label.style.display = 'none');
                    }
                }
            });
            
            // Toggle surface area visualization
            toggleSurface.addEventListener('change', function() {
                surfaceVisualizationMode = this.checked;
                
                if (surfaceVisualizationMode) {
                    // Show surface area visualization
                    const activeShape = document.querySelector('.shape-btn.active').getAttribute('data-shape');
                    createSurfaceAreaVisualization(activeShape);
                } else {
                    // Hide surface area visualization
                    if (surfaceAreaVisualization) {
                        scene.remove(surfaceAreaVisualization);
                        surfaceAreaVisualization = null;
                        
                        // Hide surface info
                        surfaceInfo.style.display = 'none';
                        
                        // Remove face area indicators
                        const faceLabels = document.querySelectorAll('.face-area');
                        faceLabels.forEach(label => label.remove());
                    }
                }
            });
            
            // Toggle net visualization
            toggleNet.addEventListener('change', function() {
                netVisualizationMode = this.checked;
                
                if (netVisualizationMode) {
                    // Show net visualization
                    const activeShape = document.querySelector('.shape-btn.active').getAttribute('data-shape');
                    createNetVisualization(activeShape);
                } else {
                    // Hide net visualization
                    if (netVisualization) {
                        scene.remove(netVisualization);
                        netVisualization = null;
                        
                        // Show 3D shape
                        if (currentShape) {
                            currentShape.visible = true;
                        }
                        
                        // Show surface visualization if it was active
                        if (surfaceVisualizationMode && surfaceAreaVisualization) {
                            surfaceAreaVisualization.visible = true;
                        }
                        
                        // Hide net info
                        netInfo.style.display = 'none';
                        
                        // Hide fold animation button
                        foldAnimationBtn.style.display = 'none';
                        
                        // Remove face labels
                        const faceLabels = document.querySelectorAll('.face-label');
                        faceLabels.forEach(label => label.remove());
                    }
                }
            });
            
            // Fold animation button
            foldAnimationBtn.addEventListener('click', animateFoldUnfold);
        });
    </script>
</body>
</html>
